//https://contest.yandex.ru/contest/25597/run-report/113812630/

/*
--Принцип работы--
Программа решает задачу разделения списка очков на две части с равной 
суммой, используя подход, аналогичный решению задачи о рюкзаке с помощью 
динамического программирования. Она начинает с проверки общей суммы 
элементов массива: если сумма нечетная, разделение невозможно. 
Затем программа создает массив dp размером равным половине суммы всех 
очков + 1. Элемент dp[i] будет true, если существует подмножество 
элементов, сумма которых равна i. Программа обновляет массив dp по 
каждому элементу списка, начиная с самой большой целевой суммы и двигаясь 
к меньшим значениям, чтобы избежать повторного использования элементов.

--Доказательство корректности--
Корректность алгоритма основана на правильной инициализации и обновлении 
массива dp.

-Инициализация dp[0] = true гарантирует, что нулевую сумму можно получить 
без использования каких-либо элементов.
-Проверка, что общая сумма всех очков четная, гарантирует, что 
теоретически возможно разделение на две равные части.
-Алгоритм обновления dp гарантирует, что каждое значение суммы 
рассматривается только один раз для каждого элемента, что исключает 
повторное использование элементов при поиске возможности получения суммы.

--Временная сложность--
Временная сложность программы составляет O(n * sum/2), где n — количество 
элементов в массиве, а sum/2 — половина суммы всех элементов. Это 
происходит потому, что каждый элемент массива используется для 
обновления массива dp от максимально возможной суммы до значения этого 
элемента.

--Пространственная сложность--
Пространственная сложность программы равна O(sum/2), где sum/2 — половина 
суммы всех элементов, так как требуется хранение массива dp этого размера. 
Дополнительное пространство для хранения входных данных не влияет на 
общую сложность, так как оно линейно зависит от n.
*/

#include <iostream>
#include <vector>
#include <numeric>  

using namespace std;

bool canPartition(vector<int>& points) {
    int totalSum = accumulate(points.begin(), points.end(), 0);

    if (totalSum % 2 != 0) return false;

    int target = totalSum / 2;
    vector<bool> dp(target + 1, false);
    dp[0] = true;

    for (int num : points) {
        for (int j = target; j >= num; --j) {
            if (dp[j - num]) dp[j] = true;
        }
    }

    return dp[target];
}

int main() {
    int n;
    cin >> n;
    vector<int> points(n);
    for (int i = 0; i < n; ++i) {
        cin >> points[i];
    }

    cout << (canPartition(points) ? "True" : "False") << endl;

    return 0;
}
