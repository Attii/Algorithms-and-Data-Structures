// https://contest.yandex.ru/contest/25070/run-report/113755669/

/*
Идея для решения была найдена тут: https://ru.stackoverflow.com/questions/1415293/%D0%9A%D0%B0%D0%BA-%D1%83%D1%81%D0%BA%D0%BE%D1%80%D0%B8%D1%82%D1%8C-%D0%BF%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D0%BA%D1%83-%D0%BE%D0%BF%D1%82%D0%B8%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D0%B3%D1%80%D0%B0%D1%84%D0%B0

--Принцип работы--
Программа использует графовое представление для проверки оптимальности 
карты железных дорог. Города представлены узлами графа, а дороги — 
рёбрами, которые помечены типами 'R' или 'B'. Программа строит граф, 
затем проверяет наличие циклов для каждого типа ребра отдельно, 
используя модифицированный метод поиска в глубину (DFS), который 
оценивает наличие путей с разными типами дорог между парой городов.

--Доказательство корректности--
Докажем корректность алгоритма методом от противного

Предположим, что карта железных дорог является оптимальной. Это означает,
что для каждой пары городов A и B,где A < B, существует маршрут только 
одного типа, R или B.

Заметим, что, исходя из условия, для любого A < n, где n - количество 
вершин, всегда описаны n-A маршрутов, таким образом из такого A всегда 
можно построить некоторый маршрут до B, где A < B < n. Таким образом мы 
исключаем ситуации, в которой не существует хотя бы одного маршрута из A 
в B. 

Производим инверсию рёбер одного типа, например, рёбер типа R. После 
инверсии:

Рёбра типа R будут идти от города с большим номером к городу с меньшим 
номером.
Рёбра типа B сохранят своё исходное направление (от меньшего к большему).
Затем применяем DFS для поиска циклов.

Предположим, метод нашел цикл. Цикл в этом контексте означает существование 
пути, который возвращается в исходную точку, проходя через рёбра обоих 
типов. Однако по предположению, карта должна быть оптимальной, и такого 
пути существовать не должно. Значит, этот цикл должен состоять только из 
рёбер одного типа только R или только B.

Если бы цикл состоял из рёбер R и B, это бы означало, что существует путь 
между какими-то городами, использующий оба типа дорог, что противоречит 
оптимальности карты. Это противоречие свидетельствует о том, что наша 
изначальная гипотеза о том, что метод может ошибочно определить карту 
как неоптимальную, неверна.

Если метод обнаруживает цикл после инверсии рёбер, это действительно 
указывает на неоптимальность карты, так как показывает, что между 
какими-то городами можно перемещаться, используя оба типа дорог.

Следовательно, предположение о возможной ошибке метода не подтверждается, 
метод корректен. Это доказывает, что если метод обнаруживает цикл, карта 
действительно не оптимальна, и наоборот, если метод не обнаруживает 
цикл, карта оптимальна.

P.S. Пример из код ревью ялвяется некорректным "1->3=>2->4=>1". Такой
цикл может получиться из графа 1->3, 1=> 4, 2=>3, 2->4, а такой граф 
по условию задачи получиться не может, так как в условии явно прописано, 
что для любого i < n выполняется условие: наличие n-i ребер. В примере же 
пропущено ребро 1 -> 2. 

--Временная сложность--
Сложность программы определяется двумя основными факторами:

1)Построение графа: O(n^2), где n - количество городов. Это связано с 
тем, что для каждого города может быть до n - 1 дорог.
2)Проверка циклов: O(V + E), где V - количество вершин, а E - количество 
ребер. В худшем случае каждая вершина соединена с каждой другой вершиной, 
что приводит к E = O(n^2).

Итоговая временная сложность алгоритма — O(n^2).

--Пространственная сложность--
Алгоритм использует:

-Граф в виде вектора векторов для хранения ребер: O(n^2) памяти.
-Вектор цветов для каждой вершины для отслеживания статуса посещения в DFS: O(n).

Итоговая пространственная сложность составляет O(n^2) из-за хранения 
графа, что является наибольшим требованием к памяти в алгоритме.
*/

#include <iostream>
#include <vector>
#include <stack>
#include <string>

using namespace std;

enum Color {
    WHITE,
    GREY,
    BLACK
};

bool contain_cycle(int s, const vector<vector<bool>>& graph, vector<Color>& color) {
    stack<int> st;
    st.push(s);

    while (!st.empty()) {
        int v = st.top();
        if (color[v] == WHITE) {
            color[v] = GREY;
            for (size_t w = 1; w < graph.size(); ++w) {  
                if (graph[v][w]) {  
                    if (color[w] == GREY) {
                        return true;
                    }
                    if (color[w] == WHITE) {
                        st.push(w);
                    }
                }
            }
        } else {
            color[v] = BLACK;
            st.pop();
        }
    }
    return false;
}

bool is_cyclic(const vector<vector<bool>>& graph) {
    vector<Color> color(graph.size(), WHITE);
    
    for (size_t i = 1; i < color.size(); ++i) {
        if (color[i] == WHITE) {
            if (contain_cycle(i, graph, color)) {
                return true;
            }
        }
    }
    return false;
}

int main() {
    int n;
    cin >> n;

    vector<vector<bool>> graph(n + 1, vector<bool>(n + 1, false));  

    string input;
    for (int i = 1; i < n; ++i) {
        cin >> input;
        for (size_t j = 0; j < input.size(); ++j) {
            if (input[j] == 'B') {
                graph[i][i + j + 1] = true;  
            } else if (input[j] == 'R') {
                graph[i + j + 1][i] = true;  
            }
        }
    }

    if (is_cyclic(graph)) {
        cout << "NO\n";
    } else {
        cout << "YES\n";
    }

    return 0;
}
